package com.github.t1.problemdetail;

import javax.xml.bind.annotation.XmlType;
import java.net.URI;
import java.util.Objects;

/**
 * Http response body containing problem details as specified in
 * <a href="https://tools.ietf.org/html/rfc7807">RFC-7807</a>
 * <p>
 * This class can be used by clients of an API that produces problem detail
 * responses to deserialize the body (entity), e.g.:
 * <pre><code>
 * Response response = target.post("/orders", ...);
 *
 * if (response.getStatusInfo() == OK) {
 *     ...
 * } else {
 *     ProblemDetail detail = response.readEntity(ProblemDetail.class);
 *     if (OUT_OF_CREDIT.equals(detail.getType())) {
 *         ...
 *     }
 * }
 * </code></pre>
 * <p>
 * If the problem detail contains extensions (custom fields) you need to access,
 * you can simply create a subclass of <code>ProblemDetail</code>, e.g.:
 * <pre><code>
 * public static class ExtendedProblemDetail extends ProblemDetail {
 *     private int balance;
 *     private List&lt;URI&gt; accounts;
 *     ...
 * }
 *
 * ...
 * ProblemDetail detail = response.readEntity(ExtendedProblemDetail.class);
 * if (detail.getBalance() &lt; 10) {
 *     ...
 * }
 * </code></pre>
 *
 * <b>Note:</b> This doesn't work with JAXB, as there can't be two types
 * with the same name and namespace. Other options like <code>@XmlAny</code>
 * would loose the type safety. You can instead unmarshal the body to an
 * xml dom document.
 * <p>
 * Extensions can also be complex, i.e. contain nested lists and mappings.
 * <p>
 * Consumers MUST use the "type" string as the primary identifier for
 * the problem type; the "title" string is advisory and included only
 * for users who are not aware of the semantics of the URI and do not
 * have the ability to discover them (e.g., offline log analysis).
 * Consumers SHOULD NOT automatically dereference the type URI.
 * <p>
 * The "status" member, if present, is only advisory; it conveys the
 * HTTP status code used for the convenience of the consumer.
 * Generators MUST use the same status code in the actual HTTP response,
 * to assure that generic HTTP software that does not understand this
 * format still behaves correctly.  See Section 5 for further caveats
 * regarding its use.
 * <p>
 * Consumers can use the status member to determine what the original
 * status code used by the generator was, in cases where it has been
 * changed (e.g., by an intermediary or cache), and when message bodies
 * persist without HTTP information.  Generic HTTP software will still
 * use the HTTP status code.
 * <p>
 * The "detail" member, if present, ought to focus on helping the client
 * correct the problem, rather than giving debugging information.
 * Consumers SHOULD NOT parse the "detail" member for information;
 * extensions are more suitable and less error-prone ways to obtain such
 * information.
 * <p>
 * Note that both "type" and "instance" accept relative URIs; this means
 * that they must be resolved relative to the document's base URI, as
 * per [RFC3986], Section 5.
 */
@XmlType(name = "problem", propOrder = {"type", "title", "status", "detail", "instance"})
public class ProblemDetail {
    @Override public String toString() {
        return "ProblemDetail:" + type + ":" + title + ":" + status + ":" + detail + ":" + instance;
    }

    /**
     * A URI reference [RFC3986] that identifies the
     * problem type.  This specification encourages that, when
     * dereferenced, it provide human-readable documentation for the
     * problem type (e.g., using HTML [W3C.REC-html5-20141028]).  When
     * this member is not present, its value is assumed to be
     * "about:blank".
     */
    private URI type;


    /**
     * A short, human-readable summary of the problem
     * type.  It SHOULD NOT change from occurrence to occurrence of the
     * problem, except for purposes of localization (e.g., using
     * proactive content negotiation; see [RFC7231], Section 3.4).
     */
    private String title;


    /**
     * The HTTP status code ([RFC7231], Section 6)
     * generated by the origin server for this occurrence of the problem.
     */
    private Integer status;


    /**
     * A human-readable explanation specific to this
     * occurrence of the problem.
     */
    private String detail;


    /**
     * A URI reference that identifies the specific
     * occurrence of the problem.  It may or may not yield further
     * information if dereferenced.
     */
    private URI instance;


    public URI getType() {return this.type;}

    public String getTitle() {return this.title;}

    public Integer getStatus() {return this.status;}

    public String getDetail() {return this.detail;}

    public URI getInstance() {return this.instance;}

    public void setType(URI type) {this.type = type; }

    public void setTitle(String title) {this.title = title; }

    public void setStatus(Integer status) {this.status = status; }

    public void setDetail(String detail) {this.detail = detail; }

    public void setInstance(URI instance) {this.instance = instance; }

    @Override public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        ProblemDetail that = (ProblemDetail) o;
        return Objects.equals(type, that.type) &&
            Objects.equals(title, that.title) &&
            Objects.equals(status, that.status) &&
            Objects.equals(detail, that.detail) &&
            Objects.equals(instance, that.instance);
    }

    @Override public int hashCode() {
        return Objects.hash(type, title, status, detail, instance);
    }
}
